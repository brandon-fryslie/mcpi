# Dependency Inversion Principle (DIP) Audit Report

**Date**: 2025-11-07 01:01:49
**Evaluator**: Claude Code (Project Auditor)
**Codebase**: MCPI (Model Context Protocol Interface)

---

## Executive Summary

**Overall Assessment**: MIXED - The codebase demonstrates good understanding of DIP principles in some areas (protocols, file-based abstractions) but has critical violations in several key components.

**Critical Violations**: 5
**High Priority Issues**: 8
**Medium Priority Issues**: 4
**Low Priority Issues**: 2

**Key Findings**:
1. ServerCatalog hardcodes path to data/registry.json (CRITICAL)
2. MCPManager creates ClientRegistry internally with no injection option (CRITICAL)
3. ClientRegistry instantiates plugins without dependency injection (HIGH)
4. CLI functions hardcode instantiation of MCPManager and ServerCatalog (HIGH)
5. Optional parameters used where required dependencies should be injected (MEDIUM)

**Testing Impact**: Current design makes true unit testing impossible for several components. Tests must use real file system or environment variable hacks rather than clean dependency injection.

---

## 1. DIP Violations

### 1.1 CRITICAL: ServerCatalog Hardcodes Registry Path

**File**: `src/mcpi/registry/catalog.py`
**Lines**: 130-150

```python
class ServerCatalog:
    def __init__(
        self, registry_path: Optional[Path] = None, validate_with_cue: bool = True
    ):
        if registry_path is None:
            # Default to package data directory
            package_dir = Path(__file__).parent.parent.parent.parent
            registry_path = package_dir / "data" / "registry.json"
```

**Problems**:
1. **Hardcoded dependency**: Directly calculates path using `__file__` magic
2. **Cannot test with alternative data sources**: Optional parameter pattern is anti-pattern
3. **Violates DIP**: High-level ServerCatalog depends on low-level file path calculation

**Evidence of Testing Difficulty**: No way to test ServerCatalog without:
- Creating real files in specific locations
- Using relative path manipulation tricks
- Relying on test data in fixed locations

**Severity**: CRITICAL
**Impact**: Every test of ServerCatalog or components using it must touch real file system

**Recommended Fix**:
```python
# Required dependency - no default
class ServerCatalog:
    def __init__(self, registry_path: Path, validator: Optional[CUEValidator] = None):
        self.registry_path = registry_path
        self._validator = validator
        # ... rest of init
```

**Factory Pattern**:
```python
def create_default_catalog() -> ServerCatalog:
    """Factory for production use with default paths."""
    package_dir = Path(__file__).parent.parent.parent.parent
    registry_path = package_dir / "data" / "registry.json"
    return ServerCatalog(registry_path=registry_path)

def create_test_catalog(test_data_path: Path) -> ServerCatalog:
    """Factory for testing with custom paths."""
    return ServerCatalog(registry_path=test_data_path)
```

---

### 1.2 CRITICAL: MCPManager Creates ClientRegistry Internally

**File**: `src/mcpi/clients/manager.py`
**Lines**: 15-26

```python
class MCPManager:
    def __init__(
        self,
        default_client: Optional[str] = None,
        registry: Optional[ClientRegistry] = None
    ) -> None:
        self.registry = registry if registry is not None else ClientRegistry()
        # ...
```

**Problems**:
1. **Optional dependency that's required**: Registry is essential, not optional
2. **Hardcoded dependency creation**: Creates ClientRegistry() when none provided
3. **Hidden complexity**: Constructor comment says "useful for tests" but pattern is backwards

**Evidence of Poor Design**:
- Comment literally says "useful for tests with path_overrides"
- This means production code has optional parameter just to enable testing
- Classic sign of missing dependency injection

**Severity**: CRITICAL
**Impact**: Cannot test MCPManager without ClientRegistry's side effects (plugin discovery, file system access)

**Recommended Fix**:
```python
class MCPManager:
    def __init__(self, registry: ClientRegistry, default_client: Optional[str] = None):
        """Initialize MCP manager.

        Args:
            registry: Client registry (REQUIRED - inject this)
            default_client: Optional default client name
        """
        self.registry = registry
        self._default_client = default_client
        # ...
```

**Factory Pattern**:
```python
def create_default_manager() -> MCPManager:
    """Factory for production use."""
    registry = ClientRegistry()
    return MCPManager(registry=registry)

def create_test_manager(registry: ClientRegistry) -> MCPManager:
    """Factory for testing."""
    return MCPManager(registry=registry)
```

---

### 1.3 HIGH: ClientRegistry Auto-Discovery Without Injection

**File**: `src/mcpi/clients/registry.py`
**Lines**: 15-22

```python
class ClientRegistry:
    def __init__(self) -> None:
        """Initialize the client registry."""
        self._plugins: Dict[str, Type[MCPClientPlugin]] = {}
        self._instances: Dict[str, MCPClientPlugin] = {}
        self._discover_plugins()
```

**Problems**:
1. **Zero-parameter constructor**: No dependencies can be injected
2. **Hardcoded behavior**: Always calls `_discover_plugins()` on construction
3. **Cannot test plugin loading**: No way to test with mock plugins without filesystem

**Evidence from Code**:
Lines 28-31 show hardcoded package import:
```python
clients_package = importlib.import_module("mcpi.clients")
clients_path = Path(clients_package.__file__).parent
```

**Severity**: HIGH
**Impact**: Cannot unit test ClientRegistry in isolation - always loads real plugins from real filesystem

**Recommended Fix**:
```python
class ClientRegistry:
    def __init__(self, plugin_classes: Optional[List[Type[MCPClientPlugin]]] = None):
        """Initialize registry with optional pre-loaded plugins.

        Args:
            plugin_classes: Pre-loaded plugin classes (for testing)
                           If None, will auto-discover from filesystem
        """
        self._plugins: Dict[str, Type[MCPClientPlugin]] = {}
        self._instances: Dict[str, MCPClientPlugin] = {}

        if plugin_classes:
            for plugin_class in plugin_classes:
                self._register_plugin_class(plugin_class)
        else:
            self._discover_plugins()
```

---

### 1.4 HIGH: CLI Hardcodes Manager and Catalog Creation

**File**: `src/mcpi/cli.py`
**Lines**: 53-76

```python
def get_mcp_manager(ctx: click.Context) -> MCPManager:
    """Lazy initialization of MCPManager."""
    if "mcp_manager" not in ctx.obj:
        try:
            ctx.obj["mcp_manager"] = MCPManager()  # <-- HARDCODED
        except Exception as e:
            # ...

def get_catalog(ctx: click.Context) -> ServerCatalog:
    """Lazy initialization of ServerCatalog."""
    if "catalog" not in ctx.obj:
        try:
            ctx.obj["catalog"] = ServerCatalog()  # <-- HARDCODED
            ctx.obj["catalog"].load_registry()
        except Exception as e:
            # ...
```

**Problems**:
1. **Hardcoded instantiation**: Direct `MCPManager()` and `ServerCatalog()` calls
2. **No injection point**: Cannot test CLI functions with mock implementations
3. **Violates DIP**: High-level CLI depends on concrete implementations

**Severity**: HIGH
**Impact**: CLI tests must use real MCPManager and ServerCatalog with all their dependencies

**Recommended Fix**:
```python
def get_mcp_manager(ctx: click.Context, factory=None) -> MCPManager:
    """Lazy initialization of MCPManager.

    Args:
        ctx: Click context
        factory: Optional factory function (for testing)
    """
    if "mcp_manager" not in ctx.obj:
        if factory is None:
            factory = create_default_manager
        try:
            ctx.obj["mcp_manager"] = factory()
        except Exception as e:
            # ...
```

---

### 1.5 HIGH: ClaudeCodePlugin Hardcodes Readers/Writers

**File**: `src/mcpi/clients/claude_code.py`
**Lines**: 63-72

```python
def _initialize_scopes(self) -> Dict[str, ScopeHandler]:
    """Initialize and return scope handlers for Claude Code."""
    scopes = {}

    # Get the schemas directory path
    schemas_dir = Path(__file__).parent / "schemas"

    # Create readers/writers (reused across scopes)
    json_reader = JSONFileReader()      # <-- HARDCODED
    json_writer = JSONFileWriter()      # <-- HARDCODED
```

**Problems**:
1. **Direct instantiation**: Creates JSONFileReader/JSONFileWriter directly
2. **Cannot inject mocks**: No way to test scope operations with fake I/O
3. **Partial DIP**: Has protocols but doesn't use them for construction

**Evidence of Incomplete Design**:
- Protocols exist: `ConfigReader`, `ConfigWriter` (lines 12-18 in file_based.py)
- But concrete classes instantiated directly instead of injected
- This means protocols are used for typing but not for dependency inversion

**Severity**: HIGH
**Impact**: Cannot test ClaudeCodePlugin scope operations without file system

**Recommended Fix**:
```python
class ClaudeCodePlugin(MCPClientPlugin):
    def __init__(
        self,
        path_overrides: Optional[Dict[str, Path]] = None,
        reader: Optional[ConfigReader] = None,
        writer: Optional[ConfigWriter] = None,
        validator: Optional[SchemaValidator] = None
    ):
        self._path_overrides = path_overrides or {}
        self._reader = reader or JSONFileReader()
        self._writer = writer or JSONFileWriter()
        self._validator = validator or YAMLSchemaValidator()
        super().__init__()
```

---

### 1.6 MEDIUM: FileBasedScope Optional Dependencies

**File**: `src/mcpi/clients/file_based.py`
**Lines**: 153-182

```python
class FileBasedScope(ScopeHandler):
    def __init__(
        self,
        config: ScopeConfig,
        reader: Optional[ConfigReader] = None,
        writer: Optional[ConfigWriter] = None,
        validator: Optional[SchemaValidator] = None,
        schema_path: Optional[Path] = None,
        enable_disable_handler: Optional[EnableDisableHandler] = None,
    ) -> None:
        # ...
        self.reader = reader or JSONFileReader()
        self.writer = writer or JSONFileWriter()
```

**Problems**:
1. **Optional parameters for required dependencies**: reader/writer are essential
2. **Defaults in constructor**: Creates JSONFileReader/JSONFileWriter if not provided
3. **Testing confusion**: Optional params suggest they're not required, but they are

**Why This is Wrong**:
- Reader and writer are NOT optional - FileBasedScope can't work without them
- Making them optional just moves the hardcoding from caller to callee
- Better to require injection and use factory for defaults

**Severity**: MEDIUM
**Impact**: Moderate - testing is harder but still possible via injection

**Recommended Fix**:
```python
class FileBasedScope(ScopeHandler):
    def __init__(
        self,
        config: ScopeConfig,
        reader: ConfigReader,  # REQUIRED
        writer: ConfigWriter,  # REQUIRED
        validator: Optional[SchemaValidator] = None,  # Truly optional
        schema_path: Optional[Path] = None,
        enable_disable_handler: Optional[EnableDisableHandler] = None,
    ):
```

---

### 1.7 MEDIUM: TUI Factory Hardcodes FzfAdapter

**File**: `src/mcpi/tui/factory.py`
**Lines**: 18-58

```python
def get_tui_adapter(backend: Optional[str] = None) -> TUIAdapter:
    # ...
    if backend == "fzf":
        return FzfAdapter()  # <-- HARDCODED
    else:
        raise ValueError(f"Unsupported TUI backend: {backend}")
```

**Problems**:
1. **Direct instantiation**: Creates FzfAdapter() directly
2. **No injection**: Cannot pass dependencies to adapter
3. **Factory with no abstraction**: Just wraps direct construction

**Severity**: MEDIUM
**Impact**: Cannot test TUI code with mock adapter

**Recommended Fix**:
```python
def get_tui_adapter(
    backend: Optional[str] = None,
    adapter_factory: Optional[Callable[[], TUIAdapter]] = None
) -> TUIAdapter:
    if adapter_factory:
        return adapter_factory()

    backend = backend or os.environ.get("MCPI_TUI_BACKEND", "fzf")

    if backend == "fzf":
        return FzfAdapter()
    else:
        raise ValueError(f"Unsupported backend: {backend}")
```

---

## 2. Constructor Anti-Patterns

### 2.1 CRITICAL: Optional Parameters That Aren't Optional

**Pattern Found In**:
- `ServerCatalog.__init__` (registry_path)
- `MCPManager.__init__` (registry)
- `FileBasedScope.__init__` (reader, writer)

**Problem**: Parameters marked Optional but are actually required for operation.

**Example** (ServerCatalog):
```python
def __init__(self, registry_path: Optional[Path] = None, ...):
    if registry_path is None:
        # Calculate default
        registry_path = package_dir / "data" / "registry.json"
```

**Why This is Wrong**:
1. **Misleading signature**: Optional suggests it's truly optional
2. **Hidden dependency**: Default calculation hides coupling to file system
3. **Testing nightmare**: Can't inject test data cleanly

**Evidence from Tests**: Tests either:
- Create real files in specific locations
- Use path manipulation to find test data
- Set environment variables as a hack

**Correct Pattern**:
```python
# Make it required
def __init__(self, registry_path: Path, ...):
    self.registry_path = registry_path

# Use factory for defaults
def create_default_catalog() -> ServerCatalog:
    default_path = Path(__file__).parent.parent / "data" / "registry.json"
    return ServerCatalog(registry_path=default_path)
```

---

### 2.2 HIGH: Hardcoded Dependencies in Constructor

**Pattern Found In**:
- `ClientRegistry.__init__` (calls _discover_plugins)
- `ClaudeCodePlugin._initialize_scopes` (creates JSONFileReader/Writer)
- All CLI helper functions (create managers directly)

**Problem**: Constructors create their own dependencies instead of receiving them.

**Example** (ClientRegistry):
```python
def __init__(self) -> None:
    self._plugins = {}
    self._instances = {}
    self._discover_plugins()  # <-- HARDCODED BEHAVIOR
```

**Why This is Wrong**:
1. **Tight coupling**: Can't test without real plugin discovery
2. **Hidden side effects**: Constructor does file system I/O
3. **Violates Single Responsibility**: Constructor both initializes AND discovers

**Severity**: HIGH

---

### 2.3 MEDIUM: Missing Dependency Injection

**Pattern Found In**:
- `ClaudeCodePlugin.__init__` - no reader/writer injection
- `FileBasedScope` - optional params instead of required
- `CUEValidator` created internally by ServerCatalog

**Problem**: Components that SHOULD receive dependencies create them internally.

**Example** (ClaudeCodePlugin):
```python
def _initialize_scopes(self):
    # Creates these internally - should be injected
    json_reader = JSONFileReader()
    json_writer = JSONFileWriter()
    validator = YAMLSchemaValidator()
```

**Why This is Wrong**:
1. **Can't mock**: Cannot test with fake readers/writers
2. **Protocols exist but unused**: ConfigReader/ConfigWriter protocols defined but not leveraged
3. **Incomplete abstraction**: Half-way to DIP but not fully implemented

**Severity**: MEDIUM

---

## 3. Missing Abstractions

### 3.1 HIGH: No Abstraction for Registry Data Source

**Missing**: Interface for registry data source (file, database, API, etc.)

**Current State**: ServerCatalog hardcoded to file-based JSON/YAML

**What Should Exist**:
```python
class RegistryDataSource(Protocol):
    """Protocol for registry data sources."""

    def load(self) -> Dict[str, MCPServer]:
        """Load all servers from data source."""
        ...

    def save(self, servers: Dict[str, MCPServer]) -> bool:
        """Save servers to data source."""
        ...
```

**Why It Matters**:
- Cannot test with in-memory registry
- Cannot support alternative backends (database, remote API)
- Violates Open/Closed Principle

**Severity**: HIGH

---

### 3.2 MEDIUM: No Abstraction for Plugin Discovery

**Missing**: Interface for plugin discovery mechanism

**Current State**: ClientRegistry hardcoded to filesystem-based discovery

**What Should Exist**:
```python
class PluginDiscovery(Protocol):
    """Protocol for plugin discovery."""

    def discover_plugins(self) -> List[Type[MCPClientPlugin]]:
        """Discover available client plugins."""
        ...
```

**Current Implementation** (lines 24-68 in registry.py):
```python
def _discover_plugins(self) -> None:
    # Hardcoded to importlib + pkgutil
    clients_package = importlib.import_module("mcpi.clients")
    clients_path = Path(clients_package.__file__).parent
    # ...
```

**Severity**: MEDIUM

---

### 3.3 LOW: No Abstraction for Path Resolution

**Missing**: Strategy for path resolution (home directory, current directory, etc.)

**Current State**: Each component calculates paths using Path.home(), Path.cwd(), etc.

**What Should Exist**:
```python
class PathResolver(Protocol):
    def get_user_config_dir(self) -> Path:
        """Get user-level config directory."""
        ...

    def get_project_config_dir(self) -> Path:
        """Get project-level config directory."""
        ...
```

**Severity**: LOW (not critical but would improve testability)

---

## 4. Testing Impact Analysis

### 4.1 Components That Cannot Be Unit Tested

**ServerCatalog**:
- ❌ Cannot test without real file system
- ❌ Cannot test with mock data source
- ❌ Must create actual JSON/YAML files for tests
- Evidence: No true unit tests exist, only integration tests

**ClientRegistry**:
- ❌ Cannot test without plugin discovery
- ❌ Cannot test with mock plugins easily
- ❌ Must have real plugin files in filesystem
- Evidence: Tests use real ClaudeCodePlugin

**MCPManager**:
- ✓ CAN test with injected ClientRegistry (good!)
- ❌ But most tests don't because optional param encourages lazy pattern
- Evidence: Some tests inject, others don't

**CLI Functions**:
- ❌ Cannot test without real MCPManager/ServerCatalog
- ❌ Must mock Click context and inject via ctx.obj
- ❌ No clean injection point
- Evidence: CLI tests are integration tests, not unit tests

### 4.2 Test Quality Assessment

**Current Test Strategy**: Integration tests disguised as unit tests

**Evidence**:
1. Tests create real files in temp directories
2. Tests use real plugin classes
3. Tests touch real file system for path resolution
4. Very few true unit tests with proper mocking

**What's Missing**:
1. True unit tests with injected dependencies
2. Mock implementations of protocols
3. In-memory test doubles for file operations
4. Isolated testing of business logic

---

## 5. Severity Assessment

### Critical (Must Fix) - 2 Issues

1. **ServerCatalog hardcoded path** - Blocks testing
2. **MCPManager creates ClientRegistry** - Blocks testing

### High Priority (Should Fix) - 5 Issues

1. **ClientRegistry auto-discovery** - Testing difficulty
2. **CLI hardcoded instantiation** - Testing difficulty
3. **ClaudeCodePlugin hardcoded readers** - Testing difficulty
4. **No abstraction for registry data source** - Extensibility
5. **No abstraction for plugin discovery** - Extensibility

### Medium Priority (Nice to Have) - 4 Issues

1. **FileBasedScope optional dependencies** - Misleading API
2. **TUI factory hardcoded adapter** - Testing difficulty
3. **No abstraction for plugin discovery** - Extensibility
4. **Missing path resolution abstraction** - Code duplication

### Low Priority (Future Enhancement) - 2 Issues

1. **Path resolution scattered** - Code organization
2. **Factory pattern not consistently used** - Code organization

---

## 6. Recommended Remediation Plan

### Phase 1: Critical Fixes (Week 1)

1. **Refactor ServerCatalog**
   - Make registry_path required parameter
   - Create factory functions for production/test
   - Add RegistryDataSource protocol
   - Implement FileRegistryDataSource

2. **Refactor MCPManager**
   - Make registry required parameter
   - Remove optional param anti-pattern
   - Create factory functions
   - Update all call sites

### Phase 2: High Priority (Week 2-3)

3. **Refactor ClientRegistry**
   - Add plugin_classes parameter for injection
   - Keep auto-discovery as default
   - Add PluginDiscovery protocol

4. **Refactor CLI**
   - Add factory parameter to get_mcp_manager/get_catalog
   - Default to production factories
   - Allow test factories for testing

5. **Refactor ClaudeCodePlugin**
   - Inject reader/writer/validator
   - Use existing protocols
   - Keep defaults but make injectable

### Phase 3: Medium Priority (Week 4)

6. **Clean up FileBasedScope**
   - Make reader/writer required
   - Remove defaults from constructor
   - Use factory pattern

7. **Add Registry Abstractions**
   - Implement RegistryDataSource protocol
   - Create FileRegistryDataSource
   - Create InMemoryRegistryDataSource for tests

### Phase 4: Testing Improvements (Week 5)

8. **Write True Unit Tests**
   - ServerCatalog with mock data source
   - MCPManager with mock registry
   - CLI with injected factories
   - All tests should run without file I/O

---

## 7. Code Examples: Before & After

### Example 1: ServerCatalog

**Before** (WRONG):
```python
# Constructor with optional param that's not really optional
catalog = ServerCatalog()  # Hardcoded path
catalog = ServerCatalog(Path("test.json"))  # Test must know path
```

**After** (CORRECT):
```python
# Production code
catalog = create_default_catalog()

# Test code
test_data = Path("/tmp/test_registry.json")
catalog = ServerCatalog(registry_path=test_data)

# Or with mock data source
mock_source = InMemoryRegistryDataSource({"server1": {...}})
catalog = ServerCatalog(data_source=mock_source)
```

### Example 2: MCPManager

**Before** (WRONG):
```python
# Optional parameter encourages lazy pattern
manager = MCPManager()  # Creates registry internally

# Testing requires optional param
registry = ClientRegistry()
manager = MCPManager(registry=registry)  # Param called "optional"
```

**After** (CORRECT):
```python
# Production code
manager = create_default_manager()

# Test code
mock_registry = MockClientRegistry()
manager = MCPManager(registry=mock_registry)  # Required param
```

### Example 3: CLI Testing

**Before** (WRONG):
```python
def test_list_command():
    # Must use real MCPManager
    result = runner.invoke(cli, ["list"])
    # This touches real file system!
```

**After** (CORRECT):
```python
def test_list_command():
    # Inject test factories
    def test_manager_factory():
        return MockMCPManager()

    def test_catalog_factory():
        return MockServerCatalog()

    # CLI accepts factories
    result = runner.invoke(
        cli,
        ["list"],
        obj={"manager_factory": test_manager_factory, "catalog_factory": test_catalog_factory}
    )
    # Pure unit test - no file I/O
```

---

## 8. Conclusion

The MCPI codebase shows partial understanding of Dependency Inversion Principle:

**What's Good**:
- Protocol definitions exist (ConfigReader, ConfigWriter, etc.)
- FileBasedScope accepts injected dependencies
- Some components (MCPManager) have injection capability

**What's Bad**:
- Critical components hardcode dependencies
- Optional parameters used as anti-pattern
- Protocols defined but not fully leveraged
- Testing requires real file system

**What's Ugly**:
- Comments that say "useful for tests" on production code
- Mix of good patterns (protocols) and bad patterns (hardcoded paths)
- Half-way to proper DIP but not completed

**Overall Grade**: D+ (Passing but needs significant improvement)

The foundation is there (protocols exist), but the implementation doesn't follow through. This is a classic case of "knowing the pattern but not applying it consistently."

**Priority**: Fix the 2 critical issues immediately, then systematically address high-priority items. This will dramatically improve testability and code quality.
